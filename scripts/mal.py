# https://docs.python.org/3/library/xml.etree.elementtree.html
from typing import Callable
import xml.etree.ElementTree as ET
from xml.etree.ElementTree import Element
import json
import glob
from datetime import datetime
from enum import Enum, auto
from functools import partial
"""
Library to parse XML exports generated by MyAnimeList into JSON:
https://myanimelist.net/panel.php?go=export
"""

### initial parsing of export folder

# folder containing exports
EXPORT_PATH = "_assets/export"
# default user_id field
USER_ID = 7702594

# MAL's internal way to represent list type
class ListType(Enum):
    ANIME = 1
    MANGA = 2

# parse exports
EXPORTS = []
for export in sorted(glob.glob(f"{EXPORT_PATH}/*.xml")):
    list_type, timestamp, _, user_id = export.split("/")[-1].split("_")
    EXPORTS.append({
        "type": ListType[list_type.split("list")[0].upper()],
        "date": datetime.fromtimestamp(float(timestamp)),
        "user": int(user_id.split(".")[0]),
        "path": export,
    })

### field level parsing

# MAL indicates an empty date as all 0's
DATE_FMT = "%Y-%m-%d"
EMPTY_DATE = "0000-00-00"

def to_date(date: str) -> datetime | None:
    """ Parse a date in the form YYYY-MM-DD. """
    return None if date == EMPTY_DATE else datetime.strptime(date, DATE_FMT)

def date_str(date_obj: datetime | None) -> str:
    """ Serialize a date in the form YYYY-MM-DD. """
    return date_obj.strftime(DATE_FMT) if date_obj is not None else EMPTY_DATE

# enumerations

class IntBool(Enum):
    FALSE = 0
    TRUE = 1

class StringBool(Enum):
    FALSE = "NO"
    TRUE = "YES"

class AnimeType(Enum):
    TV = "TV"
    MOVIE = "Movie"
    SPECIAL = "Special"
    OVA = "OVA"
    ONA = "ONA"
    MUSIC = "Music"
    UNKNOWN = "Unknown"

class Score(Enum):
    SCORE0 = 0
    SCORE1 = 1
    SCORE2 = 2
    SCORE3 = 3
    SCORE4 = 4
    SCORE5 = 5
    SCORE6 = 6
    SCORE7 = 7
    SCORE8 = 8
    SCORE9 = 9
    SCORE10 = 10
    # https://docs.python.org/3/library/enum.html#duplicating-enum-members-and-values
    # this are aliases for the above, taken from MAL's display names
    UNSCORED = 0
    APPALLING = 1
    HORRIBLE = 2
    VERYBAD = 3
    BAD = 4
    AVERAGE = 5
    FINE = 6
    GOOD = 7
    VERYGOOD = 8
    GREAT = 9
    MASTERPIECE = 10

class Status(Enum):
    VIEWING = "{verb}ing"
    COMPLETED = "Completed"
    ONHOLD = "On-Hold"
    DROPPED = "Dropped"
    PLANTOVIEW = "Plan to {verb}"

# can't subclass enums so just pretend to

class AnimeStatus(Enum):
    WATCHING = "Watching"
    COMPLETED = "Completed"
    ONHOLD = "On-Hold"
    DROPPED = "Dropped"
    PLANTOWATCH = "Plan to Watch"

class MangaStatus(Enum):
    READING = "Reading"
    COMPLETED = "Completed"
    ONHOLD = "On-Hold"
    DROPPED = "Dropped"
    PLANTOREAD = "Plan to Read"

class Priority(Enum):
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"

class AnimePriority(Enum):
    LOW = "LOW"
    MEDIUM = "MEDIUM"
    HIGH = "HIGH"

class MangaPriority(Enum):
    LOW = "Low"
    MEDIUM = "Medium"
    HIGH = "High"

def enum_value(member):
    """ Get the value of an enum member. """
    return member.value

def enum_str(member) -> str:
    """ Convert an enum member to a string. """
    return member.name.lower()

def enum_bool(member: IntBool | StringBool) -> bool:
    """ Convert an enum representing a boolean to an actual boolean. """
    return member == type(member).TRUE

def bool_str(member, strategy: IntBool | StringBool) -> str:
    """ Convert a boolean to its right representation. """
    if isinstance(member, strategy):
        return enum_value(member)
    else:
        # take the truthy or falsey value of the given type
        # this allows strict checking on input but
        # permissive values when serializing as output
        return bool_str(strategy[str(bool(member)).upper()], strategy)

### XML parsing

def short_name(field: str) -> str:
    """ Remove the first word in an underscored field name. """
    return "_".join(field.split("_")[1:])

def call(*functions: list[Callable]):
    """ Return a function which calls  a list of functions on the input. """

    def f(value):
        for function in functions:
            value = function(value)
        return value

    return f

def check_value(values: list, reference):
    """ Return a function which checks if the value is in the list. """

    def f(value):
        if value not in values:
            raise ValueError(f"'{value}' is not a valid {reference.__name__}.")
        return value

    return f

# empty type. this is preferred over str because str will map None to "None"
# and anyways, if the .text field of an Element exists, it defaults to str
nop = lambda x: x

to_ListType = call(int, ListType)
to_Score = call(int, Score)
to_AnimeStatus = call(
    AnimeStatus, enum_value, lambda value: {
        "Watching": "{verb}ing",
        "Plan to Watch": "Plan to {verb}",
    }.get(value, value), Status)
to_MangaStatus = call(
    MangaStatus, enum_value, lambda value: {
        "Reading": "{verb}ing",
        "Plan to Read": "Plan to {verb}",
    }.get(value, value), Status)
# although these are the same, distinguish for later output
# also force the strictest checking possible (exact case)
to_AnimePriority = call(AnimePriority, enum_value, str.lower, Priority)
to_MangaPriority = call(MangaPriority, enum_value, str.lower, Priority)
to_IntBool = call(int, IntBool, enum_bool)
to_StringBool = call(StringBool, enum_bool)

# declare fields primarily for introspection purposes
EXPORT_FIELDS = (
    ("type", ListType),
    ("date", datetime.fromtimestamp),
    ("user", int),
    ("path", nop),
)

HEADER_FIELDS = (
    ("user_id", int),
    ("user_export_type", to_ListType), # either 1 (anime) or 2 (manga)
)

ANIME_INFO_FIELDS = (
    ("user_id", int),
    ("user_name", nop),
    ("user_export_type", to_ListType),
    ("user_total_anime", int),
    ("user_total_watching", int),
    ("user_total_completed", int),
    ("user_total_onhold", int),
    ("user_total_dropped", int),
    ("user_total_plantowatch", int),
)

MANGA_INFO_FIELDS = (
    ("user_id", int),
    ("user_name", nop),
    ("user_export_type", to_ListType),
    ("user_total_manga", int),
    ("user_total_reading", int),
    ("user_total_completed", int),
    ("user_total_onhold", int),
    ("user_total_dropped", int),
    ("user_total_plantoread", int),
)

short_field_type = lambda fields: [
    (short_name(field), field_type)
    for field, field_type in fields
]
INFO_TO_TYPE = {
    0: EXPORT_FIELDS,
    "anime": ANIME_INFO_FIELDS,
    ListType.ANIME: short_field_type(ANIME_INFO_FIELDS),
    "manga": MANGA_INFO_FIELDS,
    ListType.MANGA: short_field_type(MANGA_INFO_FIELDS),
}

ANIME_DATA_FIELDS = (
    ("series_animedb_id", int),
    ("series_title", nop),
    ("series_type", AnimeType),
    ("series_episodes", int),
    ("my_id", int),                    # not sure what this represents
    ("my_watched_episodes", int),
    ("my_start_date", to_date),
    ("my_finish_date", to_date),
    ("my_rated", nop),                 # not sure what this represents
    ("my_score", to_Score),            # a score of 0 is unscored
    ("my_storage", nop),               # not sure what this represents
    ("my_storage_value", float),       # not sure what this represents
    ("my_status", to_AnimeStatus),
    ("my_comments", nop),
    ("my_times_watched", int),         # not including first viewing
    ("my_rewatch_value", nop),
    ("my_priority", to_AnimePriority),
    ("my_tags", nop),
    ("my_rewatching", to_IntBool),
    ("my_rewatching_ep", int),
    ("my_discuss", to_IntBool),
    ("my_sns", nop),                   # not sure what this represents
    ("update_on_import", to_IntBool),
)

MANGA_DATA_FIELDS = (
    ("manga_mangadb_id", int),
    ("manga_title", nop),
    ("manga_volumes", int),
    ("manga_chapters", int),
    ("my_id", int),
    ("my_read_volumes", int),
    ("my_read_chapters", int),
    ("my_start_date", to_date),
    ("my_finish_date", to_date),
    ("my_scanalation_group", nop),
    ("my_score", to_Score),
    ("my_storage", nop),
    ("my_retail_volumes", int),        # not sure what this means
    ("my_status", to_MangaStatus),
    ("my_comments", nop),
    ("my_times_read", int),
    ("my_tags", nop),
    ("my_priority", to_MangaPriority),
    ("my_reread_value", nop),
    ("my_rereading", to_StringBool),
    ("my_discuss", to_StringBool),
    ("my_sns", nop),
    ("update_on_import", to_IntBool),
)

DATA_TO_TYPE = {
    ListType.ANIME: ANIME_DATA_FIELDS,
    ListType.MANGA: MANGA_DATA_FIELDS,
}

def get_field(root: Element | dict[str, object], field: str) -> str:
    """ Get the value associated with a field. """
    if isinstance(root, Element):
        child = root.find(field)
        if child is not None:
            return child.text
        raise ValueError(f"Could not find field {field} in element {root}.")
    elif isinstance(root, dict):
        return root[field]
    else:
        raise ValueError(f"Invalid root {root}.")

def parse_fields(root: Element | dict[str, object],
                 fields: tuple[str, Callable],
                 shorten: bool=False) -> dict:
    """ Parse root according to the rules in fields. """
    field_name = short_name if shorten else nop
    return {
        field_name(field): field_type(get_field(root, field))
        for field, field_type in fields
    }

def parse_header(path: str) -> dict:
    """ Parse only the user_id and user_export_type fields. """
    tree = ET.parse(path)
    root = tree.getroot()
    return parse_fields(root.find("myinfo"), HEADER_FIELDS, shorten=True)

def parse_export(path: str, from_string: bool=False) -> dict:
    """ Parse the XML into a Python internal representation. """
    # parse from file
    if not from_string:
        tree = ET.parse(path)
        root = tree.getroot()
    # parse from provided string data
    else:
        root = ET.fromstring(path)

    info = root.find("myinfo")
    list_type = parse_fields(info, HEADER_FIELDS)["user_export_type"]
    type_name = enum_str(list_type)
    return {
        "info": parse_fields(info, INFO_TO_TYPE[type_name], shorten=True),
        list_type: [
            parse_fields(entry, DATA_TO_TYPE[list_type])
            for entry in root.findall(type_name)
        ],
    }

def parse_json(path: str, from_string: bool=False) -> dict:
    """ Parse the JSON into a Python internal representation. """
    if not from_string:
        with open(path) as f:
            data = json.load()
    else:
        data = json.loads(path)

    list_type = ListType(data["info"]["export_type"])
    type_name = enum_str(list_type)
    # be more permissive on booleans than XML
    # take the truthy or falsey value for the value
    data_to_type = dict(DATA_TO_TYPE[list_type])
    for key in ("my_rewatching" if list_type == ListType.ANIME else \
                "my_rereading", "my_discuss", "update_on_import"):
        data_to_type[key] = nop
    return {
        "info": parse_fields(data["info"], INFO_TO_TYPE[list_type]),
        list_type: [
            parse_fields(entry, data_to_type.items())
            for entry in data[type_name]
        ],
    }

def get_last_export(list_type: ListType=ListType.ANIME,
                    user_id: int=USER_ID,
                    deep: bool=False) -> dict:
    """ Get the most recently exported list for the user.

    If deep is true, this function uses the XML instead of the filename.
    """
    # sorted lexicographically by list type, timestamp, user id
    for export in reversed(EXPORTS):
        # parse just the header of the XML
        if deep:
            data = parse_header(export["path"])
            if data["id"] == user_id and data["export_type"] == list_type:
                return parse_export(export["path"])
        # get the data from the filename
        else:
            if export["user"] == user_id and export["type"] == list_type:
                return parse_export(export["path"])
    raise ValueError(f"{enum_str(list_type)} list "
                     f"not found for user {user_id}.")

def get_list_type(data: dict) -> ListType:
    """ Return the type of the list. """
    for list_type in ListType:
        if list_type in data:
            return list_type
    raise ValueError("Type of the data not found.")

def dict_view(data: dict) -> dict:
    """ Return a dictionary view of the form title: attributes.

    Modifying this view modifies the original data.
    """
    list_type = get_list_type(data)
    title_field = {
        ListType.ANIME: "series_title",
        ListType.MANGA: "manga_title",
    }[list_type]
    return {
        entry[title_field]: entry
        for entry in data[list_type]
    }

### serialization methods

# enums, use enum values
ENUMS = {
    field_type: enum_value for field_type in [
        to_ListType, to_Score, AnimeType, AnimeStatus, MangaStatus
    ]
} | {
    # although Status is a pure fabrication abstraction representing
    # both anime and manga, they are obviously serialized differently
    to_AnimeStatus: call(enum_value, partial(str.format, verb="Watch")),
    to_MangaStatus: call(enum_value, partial(str.format, verb="Read")),
    # although Priority represents both anime and manga,
    # they are serialized differently in the string output
    to_AnimePriority: call(enum_value, str.upper),
    to_MangaPriority: call(enum_value, str.capitalize),
    # make special cases for booleans for convenience
    to_IntBool: partial(bool_str, strategy=IntBool),
    to_StringBool: partial(bool_str, strategy=StringBool),
}

TO_JSON = ENUMS | {
    to_date: date_str,
    to_IntBool: bool,
    to_StringBool: bool,
} | {
    # fields native to JSON, do nothing
    field_type: nop for field_type in [
        nop, str, int, float, bool,
    ]
}

# by default, serialize using str so only record exceptions.
TO_STR = ENUMS | {
    nop: lambda value: str(value) if value is not None else "",
    int: str,
    float: partial(str.format, "{:.2f}"),
    to_date: date_str,
    ListType: enum_str,
    datetime.fromtimestamp: str,
}

# fields to wrap in <![CDATA[actual data here]]>
FIELDS_WRAP = {
    "series_title",
    "manga_title",
    "my_scanalation_group",
    "my_comments",
    "my_tags",
}

def to_json(data: dict) -> str:
    """ Serialize JSON data as a string. """
    return json.dumps(data, sort_keys=False, indent=4)

def cdata_wrap(key: str, value: str) -> str:
    """ Wrap the value in CDATA if necessary. """
    # Python's XML parser seems to remove the carriage returns
    # so this may not be exactly the value in the original file
    return f"<![CDATA[{value.replace(chr(10), chr(10))}]]>" \
        if key in FIELDS_WRAP else value

def serialize_data(data: dict,
                   field_to_type: tuple[str, Callable] | dict[str, Callable],
                   type_lookup: dict[Callable, Callable]=TO_STR,
                   wrap: bool=False) -> dict[str, str]:
    """ Serialize each value in the entry dictionary. """
    if not isinstance(field_to_type, dict):
        field_to_type = dict(field_to_type)
    wrapper = cdata_wrap if wrap else lambda key, value: value
    return {
        key: wrapper(key, type_lookup[field_to_type[key]](value))
        for key, value in data.items()
    }

def data_to_json(data: dict) -> str:
    """ Serialize the parsed anime list data as JSON. """
    list_type = get_list_type(data)
    type_name = enum_str(list_type)
    return to_json({
        "info": serialize_data(data["info"], INFO_TO_TYPE[list_type], TO_JSON),
        type_name: [
            serialize_data(entry, DATA_TO_TYPE[list_type], TO_JSON)
            for entry in data[list_type]
        ],
    })

def data_to_xml(data: dict) -> str:
    """ Serialize the parsed anime list data as XML.

    This function carefully copies the format of the original XML.
    """
    list_type = get_list_type(data)
    type_name = enum_str(list_type)
    info = serialize_data(data["info"], INFO_TO_TYPE[list_type])
    entry_to_str = partial(serialize_data,
                           field_to_type=DATA_TO_TYPE[list_type], wrap=True)
    eol, tab = "\n", "\t"
    indent = "\t\t" if list_type == ListType.ANIME else "\t"
    first_line = "\n\t" if list_type == ListType.MANGA else ""
    return f"""\
<?xml version="1.0" encoding="UTF-8" ?>{first_line}
{indent}<!--
{indent} Created by XML Export feature at MyAnimeList.net
{indent} Version 1.1.0
{indent}-->
{indent}
{indent}<myanimelist>
{indent}
{indent}\t<myinfo>
{eol.join(f"{indent}{2*tab}<user_{key}>{value}</user_{key}>"
          for key, value in info.items())}
{indent}\t</myinfo>
{indent}
{indent}{f"".join(
f"{eol}{4*tab}<{type_name}>{eol}"
f"{eol.join(f'{5*tab}<{key}>{value}</{key}>' for key, value in entry.items())}"
f"{eol}{4*tab}</{type_name}>{eol}{3*tab}"
               for entry in map(entry_to_str, data[list_type]))}
{indent}\t</myanimelist>
{indent}\t"""

def check_valid(data: dict) -> dict:
    """ Check that the internal representation can still be parsed.

    For example, setting an enum value outside of those possible will break.
    It is possible to be valid but different from the result of this
    function, because some flexibility is allowed with boolean values.
    """
    return parse_export(data_to_xml(data), from_string=True)

def write(path: str, data: str) -> None:
    """ Write the string data to the path. """
    with open(path, "w") as f:
        f.write(data)

if __name__ == "__main__":
    print("List of available exports:")
    for export in EXPORTS:
        print(to_json(serialize_data(export, INFO_TO_TYPE[0])))

    print(f"\nMost recent anime export for user {USER_ID}:")
    # XML -> IR, IR -> JSON, JSON -> IR, IR -> XML
    anime_list = get_last_export(ListType.ANIME)
    anime_json = data_to_json(anime_list)
    print(anime_json)
    anime_list = parse_json(anime_json, from_string=True)
    write("animelist_parsed.xml", data_to_xml(anime_list))

    print(f"\nMost recent manga export for user {USER_ID}:")
    manga_list = get_last_export(ListType.MANGA)
    manga_json = data_to_json(manga_list)
    print(manga_json)
    manga_list = parse_json(manga_json, from_string=True)
    write("mangalist_parsed.xml", data_to_xml(manga_list))

